{"version":3,"sources":["../src/local.ts"],"sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport crypto from 'crypto';\nimport sqlite3 from 'sqlite3';\nimport { open } from 'sqlite';\n\ninterface FileInfo {\n  path: string;\n  hash: string;\n  size: number;\n  modTime: Date;\n}\n\ninterface FileRecord {\n  id?: number;\n  path: string;\n  hash: string;\n  size: number;\n  modTime: string;\n  folder: string;\n  status: string; // 'active' | 'duplicate' | 'deleted'\n  mimeType: string; // 파일 타입 (image/jpeg, text/plain 등)\n  createdAt: string;\n  updatedAt: string;\n}\n\ninterface FileTag {\n  fileId: number;\n  tag: string;\n  source: string; // 'auto' | 'manual' - 태그 생성 출처\n  createdAt: string;\n}\n\n/**\n * 폴더 내 파일들의 정보를 수집\n */\nconst getFileInfos = (folderPath: string): FileInfo[] => {\n  const files: FileInfo[] = [];\n\n  const readDir = (dir: string) => {\n    const items = fs.readdirSync(dir);\n\n    for (const item of items) {\n      const fullPath = path.join(dir, item);\n      const stat = fs.statSync(fullPath);\n\n      if (stat.isDirectory()) {\n        readDir(fullPath); // 재귀적으로 하위 디렉토리 탐색\n      } else {\n        const fileBuffer = fs.readFileSync(fullPath);\n        const hash = crypto.createHash('md5').update(fileBuffer).digest('hex');\n\n        files.push({\n          path: fullPath,\n          hash: hash,\n          size: stat.size,\n          modTime: stat.mtime,\n        });\n      }\n    }\n  };\n\n  readDir(folderPath);\n  return files;\n};\n\n/**\n * 파일 DB 초기화\n */\nconst initFileDB = async () => {\n  // DB 파일 저장 경로 설정\n  const dbPath = path.join(process.cwd(), 'files.db');\n  // 또는 환경 변수나 설정 파일에서 경로 가져오기\n  // const dbPath = path.join(process.env.DB_PATH ?? '.', 'files.db');\n\n  const db = await open({\n    filename: dbPath,\n    driver: sqlite3.Database,\n  });\n\n  await db.exec(`\n    -- 파일 테이블\n    CREATE TABLE IF NOT EXISTS files (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      path TEXT NOT NULL,\n      hash TEXT NOT NULL,\n      size INTEGER NOT NULL,\n      modTime TEXT NOT NULL,\n      folder TEXT NOT NULL,\n      status TEXT DEFAULT 'active',\n      mimeType TEXT,\n      createdAt TEXT DEFAULT CURRENT_TIMESTAMP,\n      updatedAt TEXT DEFAULT CURRENT_TIMESTAMP\n    );\n\n    -- 태그 테이블\n    CREATE TABLE IF NOT EXISTS tags (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      name TEXT NOT NULL UNIQUE,\n      description TEXT,\n      createdAt TEXT DEFAULT CURRENT_TIMESTAMP\n    );\n\n    -- 파일-태그 관계 테이블\n    CREATE TABLE IF NOT EXISTS file_tags (\n      fileId INTEGER,\n      tagId INTEGER,\n      source TEXT DEFAULT 'manual',\n      createdAt TEXT DEFAULT CURRENT_TIMESTAMP,\n      PRIMARY KEY (fileId, tagId),\n      FOREIGN KEY (fileId) REFERENCES files(id) ON DELETE CASCADE,\n      FOREIGN KEY (tagId) REFERENCES tags(id) ON DELETE CASCADE\n    );\n\n    -- 인덱스\n    CREATE INDEX IF NOT EXISTS idx_hash ON files(hash);\n    CREATE INDEX IF NOT EXISTS idx_path ON files(path);\n    CREATE INDEX IF NOT EXISTS idx_mime ON files(mimeType);\n    CREATE INDEX IF NOT EXISTS idx_tags ON tags(name);\n  `);\n\n  return db;\n};\n\n/**\n * 파일 타입 감지\n */\nconst detectMimeType = (filePath: string): string => {\n  const ext = path.extname(filePath).toLowerCase();\n  // 기본적인 MIME 타입 매핑\n  const mimeTypes = {\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.png': 'image/png',\n    '.gif': 'image/gif',\n    '.pdf': 'application/pdf',\n    '.txt': 'text/plain',\n    '.md': 'text/markdown',\n    '.doc': 'application/msword',\n    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    // ... 필요한 타입 추가\n  };\n  return mimeTypes[ext] || 'application/octet-stream';\n};\n\n/**\n * 자동 태그 생성\n */\nconst generateAutoTags = async (db, fileRecord: FileRecord): Promise<string[]> => {\n  const tags = new Set<string>();\n\n  // 1. 파일 타입 기반 태그\n  tags.add(fileRecord.mimeType.split('/')[0]); // 'image', 'text' 등\n\n  // 2. 파일 크기 기반 태그\n  if (fileRecord.size > 1024 * 1024 * 100) tags.add('large-file');\n  if (fileRecord.size < 1024 * 10) tags.add('small-file');\n\n  // 3. 파일명 기반 태그\n  const fileName = path.basename(fileRecord.path).toLowerCase();\n  if (fileName.includes('screenshot')) tags.add('screenshot');\n  if (fileName.includes('backup')) tags.add('backup');\n\n  // 4. 날짜 기반 태그\n  const fileDate = new Date(fileRecord.modTime);\n  tags.add(`year-${fileDate.getFullYear()}`);\n\n  return Array.from(tags);\n};\n\n/**\n * 태그 저장\n */\nconst saveTags = async (db, fileId: number, tags: string[], source = 'auto') => {\n  for (const tag of tags) {\n    // 태그가 없으면 생성\n    await db.run(`INSERT OR IGNORE INTO tags (name) VALUES (?)`, [tag]);\n\n    // 태그 ID 조회\n    const { id: tagId } = await db.get(`SELECT id FROM tags WHERE name = ?`, [tag]);\n\n    // 파일-태그 관계 저장\n    await db.run(`INSERT OR IGNORE INTO file_tags (fileId, tagId, source) VALUES (?, ?, ?)`, [fileId, tagId, source]);\n  }\n};\n\n/**\n * 태그로 파일 검색\n */\nconst findFilesByTags = async (db, tags: string[]) => {\n  const placeholders = tags.map(() => '?').join(',');\n  return await db.all(\n    `\n    SELECT DISTINCT f.*\n    FROM files f\n    JOIN file_tags ft ON f.id = ft.fileId\n    JOIN tags t ON ft.tagId = t.id\n    WHERE t.name IN (${placeholders})\n    AND f.status = 'active'\n  `,\n    tags\n  );\n};\n\n/**\n * 파일 정보 저장 (태그 포함)\n */\nconst saveFileInfo = async (db, fileInfo: FileInfo, folder: string) => {\n  const record: FileRecord = {\n    path: fileInfo.path,\n    hash: fileInfo.hash,\n    size: fileInfo.size,\n    modTime: fileInfo.modTime.toISOString(),\n    folder: folder,\n    status: 'active',\n    mimeType: detectMimeType(fileInfo.path),\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n\n  const result = await db.run(\n    `INSERT INTO files (path, hash, size, modTime, folder, status, mimeType)\n     VALUES (?, ?, ?, ?, ?, ?, ?)\n     RETURNING id`,\n    [record.path, record.hash, record.size, record.modTime, record.folder, record.status, record.mimeType]\n  );\n\n  // 자동 태그 생성 및 저장\n  const autoTags = await generateAutoTags(db, record);\n  await saveTags(db, result.lastID, autoTags, 'auto');\n};\n\n/**\n * 중복 파일 검사 (DB 활용)\n */\nconst findDuplicates = async (db, folder: string) => {\n  const duplicates = await db.all(\n    `\n    SELECT f1.path, f1.hash, f1.size\n    FROM files f1\n    JOIN files f2 ON f1.hash = f2.hash AND f1.size = f2.size\n    WHERE f1.folder = ? AND f2.folder != f1.folder\n    AND f1.status = 'active' AND f2.status = 'active'\n  `,\n    [folder]\n  );\n\n  return duplicates;\n};\n\n/**\n * 중복 파일 상태 업데이트\n */\nconst updateFileStatus = async (db, path: string, status: string) => {\n  await db.run(\n    `\n    UPDATE files \n    SET status = ?, updatedAt = CURRENT_TIMESTAMP\n    WHERE path = ?\n  `,\n    [status, path]\n  );\n};\n\n/**\n * 중복 파일 정리 (DB 활용)\n */\nconst cleanup = async (srcFolder: string, dstFolder: string) => {\n  try {\n    // 경로 정규화 및 검증\n    srcFolder = path.normalize(srcFolder.trim());\n    dstFolder = path.normalize(dstFolder.trim());\n\n    if (!fs.existsSync(srcFolder)) {\n      throw new Error(`Source folder does not exist: ${srcFolder}`);\n    }\n    if (!fs.existsSync(dstFolder)) {\n      throw new Error(`Destination folder does not exist: ${dstFolder}`);\n    }\n\n    // DB 초기화\n    const db = await initFileDB();\n\n    // 파일 정보 수집 및 저장\n    console.log('Collecting and saving file information...');\n    const srcFiles = getFileInfos(srcFolder);\n    const dstFiles = getFileInfos(dstFolder);\n\n    for (const file of srcFiles) {\n      await saveFileInfo(db, file, srcFolder);\n    }\n    for (const file of dstFiles) {\n      await saveFileInfo(db, file, dstFolder);\n    }\n\n    // 중복 파일 찾기\n    console.log('Finding duplicates...');\n    const duplicates = await findDuplicates(db, dstFolder);\n\n    if (duplicates.length > 0) {\n      console.log(`Found ${duplicates.length} duplicate files`);\n\n      // 중복 파일 목록 저장\n      const logPath = path.join(dstFolder, 'duplicates.log');\n      fs.writeFileSync(logPath, duplicates.map((d) => d.path).join('\\n'));\n\n      // 중복 파일 처리\n      for (const file of duplicates) {\n        const backupPath = path.join(dstFolder, '_duplicates', path.relative(dstFolder, file.path));\n        fs.mkdirSync(path.dirname(backupPath), { recursive: true });\n        fs.renameSync(file.path, backupPath);\n\n        // DB 상태 업데이트\n        await updateFileStatus(db, file.path, 'duplicate');\n      }\n\n      console.log(`Moved ${duplicates.length} files to _duplicates folder`);\n      console.log(`Check duplicates.log for details`);\n    } else {\n      console.log('No duplicate files found');\n    }\n\n    await db.close();\n  } catch (error) {\n    console.error('Error during cleanup:', error);\n    throw error;\n  }\n};\n\nexport { cleanup };\n"],"names":["fs","path","crypto","sqlite3","open","getFileInfos","folderPath","files","readDir","dir","items","readdirSync","item","fullPath","join","stat","statSync","isDirectory","fileBuffer","readFileSync","hash","createHash","update","digest","push","size","modTime","mtime","initFileDB","dbPath","process","cwd","db","filename","driver","Database","exec","detectMimeType","filePath","ext","extname","toLowerCase","mimeTypes","generateAutoTags","fileRecord","tags","Set","add","mimeType","split","fileName","basename","includes","fileDate","Date","getFullYear","Array","from","saveTags","fileId","source","tag","run","id","tagId","get","findFilesByTags","placeholders","map","all","saveFileInfo","fileInfo","folder","record","toISOString","status","createdAt","updatedAt","result","autoTags","lastID","findDuplicates","duplicates","updateFileStatus","cleanup","srcFolder","dstFolder","normalize","trim","existsSync","Error","console","log","srcFiles","dstFiles","file","length","logPath","writeFileSync","d","backupPath","relative","mkdirSync","dirname","recursive","renameSync","close","error"],"mappings":"AAAA,OAAOA,QAAQ,KAAK;AACpB,OAAOC,UAAU,OAAO;AACxB,OAAOC,YAAY,SAAS;AAC5B,OAAOC,aAAa,UAAU;AAC9B,SAASC,IAAI,QAAQ,SAAS;AAgC9B,MAAMC,eAAe,CAACC;IACpB,MAAMC,QAAoB,EAAE;IAE5B,MAAMC,UAAU,CAACC;QACf,MAAMC,QAAQV,GAAGW,WAAW,CAACF;QAE7B,KAAK,MAAMG,QAAQF,MAAO;YACxB,MAAMG,WAAWZ,KAAKa,IAAI,CAACL,KAAKG;YAChC,MAAMG,OAAOf,GAAGgB,QAAQ,CAACH;YAEzB,IAAIE,KAAKE,WAAW,IAAI;gBACtBT,QAAQK;YACV,OAAO;gBACL,MAAMK,aAAalB,GAAGmB,YAAY,CAACN;gBACnC,MAAMO,OAAOlB,OAAOmB,UAAU,CAAC,OAAOC,MAAM,CAACJ,YAAYK,MAAM,CAAC;gBAEhEhB,MAAMiB,IAAI,CAAC;oBACTvB,MAAMY;oBACNO,MAAMA;oBACNK,MAAMV,KAAKU,IAAI;oBACfC,SAASX,KAAKY,KAAK;gBACrB;YACF;QACF;IACF;IAEAnB,QAAQF;IACR,OAAOC;AACT;AAKA,MAAMqB,aAAa;IAEjB,MAAMC,SAAS5B,KAAKa,IAAI,CAACgB,QAAQC,GAAG,IAAI;IAIxC,MAAMC,KAAK,MAAM5B,KAAK;QACpB6B,UAAUJ;QACVK,QAAQ/B,QAAQgC,QAAQ;IAC1B;IAEA,MAAMH,GAAGI,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuCf,CAAC;IAED,OAAOJ;AACT;AAKA,MAAMK,iBAAiB,CAACC;IACtB,MAAMC,MAAMtC,KAAKuC,OAAO,CAACF,UAAUG,WAAW;IAE9C,MAAMC,YAAY;QAChB,QAAQ;QACR,SAAS;QACT,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,SAAS;IAEX;IACA,OAAOA,SAAS,CAACH,IAAI,IAAI;AAC3B;AAKA,MAAMI,mBAAmB,OAAOX,IAAIY;IAClC,MAAMC,OAAO,IAAIC;IAGjBD,KAAKE,GAAG,CAACH,WAAWI,QAAQ,CAACC,KAAK,CAAC,IAAI,CAAC,EAAE;IAG1C,IAAIL,WAAWnB,IAAI,GAAG,OAAO,OAAO,KAAKoB,KAAKE,GAAG,CAAC;IAClD,IAAIH,WAAWnB,IAAI,GAAG,OAAO,IAAIoB,KAAKE,GAAG,CAAC;IAG1C,MAAMG,WAAWjD,KAAKkD,QAAQ,CAACP,WAAW3C,IAAI,EAAEwC,WAAW;IAC3D,IAAIS,SAASE,QAAQ,CAAC,eAAeP,KAAKE,GAAG,CAAC;IAC9C,IAAIG,SAASE,QAAQ,CAAC,WAAWP,KAAKE,GAAG,CAAC;IAG1C,MAAMM,WAAW,IAAIC,KAAKV,WAAWlB,OAAO;IAC5CmB,KAAKE,GAAG,CAAC,CAAC,KAAK,EAAEM,SAASE,WAAW,IAAI;IAEzC,OAAOC,MAAMC,IAAI,CAACZ;AACpB;AAKA,MAAMa,WAAW,OAAO1B,IAAI2B,QAAgBd,MAAgBe,SAAS,MAAM;IACzE,KAAK,MAAMC,OAAOhB,KAAM;QAEtB,MAAMb,GAAG8B,GAAG,CAAC,CAAC,4CAA4C,CAAC,EAAE;YAACD;SAAI;QAGlE,MAAM,EAAEE,IAAIC,KAAK,EAAE,GAAG,MAAMhC,GAAGiC,GAAG,CAAC,CAAC,kCAAkC,CAAC,EAAE;YAACJ;SAAI;QAG9E,MAAM7B,GAAG8B,GAAG,CAAC,CAAC,wEAAwE,CAAC,EAAE;YAACH;YAAQK;YAAOJ;SAAO;IAClH;AACF;AAKA,MAAMM,kBAAkB,OAAOlC,IAAIa;IACjC,MAAMsB,eAAetB,KAAKuB,GAAG,CAAC,IAAM,KAAKtD,IAAI,CAAC;IAC9C,OAAO,MAAMkB,GAAGqC,GAAG,CACjB,CAAC;;;;;qBAKgB,EAAEF,aAAa;;EAElC,CAAC,EACCtB;AAEJ;AAKA,MAAMyB,eAAe,OAAOtC,IAAIuC,UAAoBC;IAClD,MAAMC,SAAqB;QACzBxE,MAAMsE,SAAStE,IAAI;QACnBmB,MAAMmD,SAASnD,IAAI;QACnBK,MAAM8C,SAAS9C,IAAI;QACnBC,SAAS6C,SAAS7C,OAAO,CAACgD,WAAW;QACrCF,QAAQA;QACRG,QAAQ;QACR3B,UAAUX,eAAekC,SAAStE,IAAI;QACtC2E,WAAW,IAAItB,OAAOoB,WAAW;QACjCG,WAAW,IAAIvB,OAAOoB,WAAW;IACnC;IAEA,MAAMI,SAAS,MAAM9C,GAAG8B,GAAG,CACzB,CAAC;;iBAEY,CAAC,EACd;QAACW,OAAOxE,IAAI;QAAEwE,OAAOrD,IAAI;QAAEqD,OAAOhD,IAAI;QAAEgD,OAAO/C,OAAO;QAAE+C,OAAOD,MAAM;QAAEC,OAAOE,MAAM;QAAEF,OAAOzB,QAAQ;KAAC;IAIxG,MAAM+B,WAAW,MAAMpC,iBAAiBX,IAAIyC;IAC5C,MAAMf,SAAS1B,IAAI8C,OAAOE,MAAM,EAAED,UAAU;AAC9C;AAKA,MAAME,iBAAiB,OAAOjD,IAAIwC;IAChC,MAAMU,aAAa,MAAMlD,GAAGqC,GAAG,CAC7B,CAAC;;;;;;EAMH,CAAC,EACC;QAACG;KAAO;IAGV,OAAOU;AACT;AAKA,MAAMC,mBAAmB,OAAOnD,IAAI/B,MAAc0E;IAChD,MAAM3C,GAAG8B,GAAG,CACV,CAAC;;;;EAIH,CAAC,EACC;QAACa;QAAQ1E;KAAK;AAElB;AAKA,MAAMmF,UAAU,OAAOC,WAAmBC;IACxC,IAAI;QAEFD,YAAYpF,KAAKsF,SAAS,CAACF,UAAUG,IAAI;QACzCF,YAAYrF,KAAKsF,SAAS,CAACD,UAAUE,IAAI;QAEzC,IAAI,CAACxF,GAAGyF,UAAU,CAACJ,YAAY;YAC7B,MAAM,IAAIK,MAAM,CAAC,8BAA8B,EAAEL,WAAW;QAC9D;QACA,IAAI,CAACrF,GAAGyF,UAAU,CAACH,YAAY;YAC7B,MAAM,IAAII,MAAM,CAAC,mCAAmC,EAAEJ,WAAW;QACnE;QAGA,MAAMtD,KAAK,MAAMJ;QAGjB+D,QAAQC,GAAG,CAAC;QACZ,MAAMC,WAAWxF,aAAagF;QAC9B,MAAMS,WAAWzF,aAAaiF;QAE9B,KAAK,MAAMS,QAAQF,SAAU;YAC3B,MAAMvB,aAAatC,IAAI+D,MAAMV;QAC/B;QACA,KAAK,MAAMU,QAAQD,SAAU;YAC3B,MAAMxB,aAAatC,IAAI+D,MAAMT;QAC/B;QAGAK,QAAQC,GAAG,CAAC;QACZ,MAAMV,aAAa,MAAMD,eAAejD,IAAIsD;QAE5C,IAAIJ,WAAWc,MAAM,GAAG,GAAG;YACzBL,QAAQC,GAAG,CAAC,CAAC,MAAM,EAAEV,WAAWc,MAAM,CAAC,gBAAgB,CAAC;YAGxD,MAAMC,UAAUhG,KAAKa,IAAI,CAACwE,WAAW;YACrCtF,GAAGkG,aAAa,CAACD,SAASf,WAAWd,GAAG,CAAC,CAAC+B,IAAMA,EAAElG,IAAI,EAAEa,IAAI,CAAC;YAG7D,KAAK,MAAMiF,QAAQb,WAAY;gBAC7B,MAAMkB,aAAanG,KAAKa,IAAI,CAACwE,WAAW,eAAerF,KAAKoG,QAAQ,CAACf,WAAWS,KAAK9F,IAAI;gBACzFD,GAAGsG,SAAS,CAACrG,KAAKsG,OAAO,CAACH,aAAa;oBAAEI,WAAW;gBAAK;gBACzDxG,GAAGyG,UAAU,CAACV,KAAK9F,IAAI,EAAEmG;gBAGzB,MAAMjB,iBAAiBnD,IAAI+D,KAAK9F,IAAI,EAAE;YACxC;YAEA0F,QAAQC,GAAG,CAAC,CAAC,MAAM,EAAEV,WAAWc,MAAM,CAAC,4BAA4B,CAAC;YACpEL,QAAQC,GAAG,CAAC,CAAC,gCAAgC,CAAC;QAChD,OAAO;YACLD,QAAQC,GAAG,CAAC;QACd;QAEA,MAAM5D,GAAG0E,KAAK;IAChB,EAAE,OAAOC,OAAO;QACdhB,QAAQgB,KAAK,CAAC,yBAAyBA;QACvC,MAAMA;IACR;AACF;AAEA,SAASvB,OAAO,GAAG"}