{"version":3,"sources":["../src/builtin.ts"],"sourcesContent":["// & Import AREA\n// &---------------------------------------------------------------------------\n// ? Builtin Modules\nimport * as fs from 'fs';\nimport Path from 'path';\nimport type { FileOptions, JsonOptions } from './types.js';\n\n\n// & Functions AREA\n// &---------------------------------------------------------------------------\n// * File System\n/**\n * remove BOM(Byte Order Mark, `U+FEFF`)\n */\nconst removeBOM = (str: string) => {\n  return str\n    .replace(/^\\uFEFF/gm, '')\n    .replace(/^\\u00BB\\u00BF/gm, '')\n    .replace(/\\r\\n/g, '\\n');\n};\n\n/**\n * 폴더이름에 포함된 \"\\\\\" => \"/\"\n */\nconst slashedFolder = (folderName: string) => {\n  folderName = folderName.replace(/\\\\/g, '/');\n  return folderName.endsWith('/') ? folderName.slice(0, -1) : folderName;\n};\n\n/**\n * set Path(실행 경로 기준)\n */\nconst setPath = (path: string) => {\n  if (path.startsWith('.')) {\n    path = Path.join(process.cwd(), path);\n  }\n  return slashedFolder(path);\n};\n\n/**\n * 한글 조합형 -> 완성형\n */\nconst composeHangul = (str: string | Buffer | undefined): string => {\n  if (!str) return '';\n  return str.toString().normalize('NFKC');\n};\n\n/**\n * 파일/폴더명으로 사용할 수 없는 문자 제거\n */\nconst sanitizePath = (str: string) => {\n  if (!str) return '';\n  str = composeHangul(str);\n\n  // 윈도우에서 파일/폴더명으로 사용할 수 없는 문자 제거\n  const invalidChars = /[<>:\"/\\\\|?*\\x00-\\x1F]/g;\n  // 마침표(.)로 시작하거나 끝나는 경우 제거\n  const invalidDots = /(^\\.+|\\.+$)/g;\n  // 연속된 공백을 하나의 공백으로 변환\n  const multipleSpaces = /\\s+/g;\n\n  return str\n    .replace(invalidChars, '') // 사용할 수 없는 문자 제거\n    .replace(invalidDots, '') // 시작/끝 마침표 제거\n    .replace(multipleSpaces, ' ') // 연속된 공백을 하나로\n    .trim(); // 앞뒤 공백 제거\n};\n\n/**\n * 파일명으로 사용가능하도록 문자열 변경\n */\nconst sanitizeName = (name: string) => {\n  if (!name) return '';\n  name = composeHangul(name);\n  return name\n    .replace(/\\[/g, '(')\n    .replace(/\\]/g, ')')\n    .replace(/[^\\uAC00-\\uD7A3a-zA-Z0-9_\\(\\)\\<\\>,\\s]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n/**\n * Load data(string) from file with charset(encoding)\n */\nconst loadFile = (path: string, encoding: BufferEncoding = 'utf8') => {\n  try {\n    return removeBOM(fs.readFileSync(setPath(path), { encoding }));\n  } catch {\n    return '';\n  }\n};\n\n/**\n * Load data(json) from file with charset(encoding)\n */\nconst loadJson = (path: string, encoding: BufferEncoding = 'utf8') => {\n  try {\n    return JSON.parse(removeBOM(fs.readFileSync(setPath(path), { encoding })));\n  } catch {\n    return {};\n  }\n};\n\n/**\n * Save data to file with charset(encoding), create Folder if not exist\n * @remarks\n * if overwrite is false, append data to file\n */\nconst saveFile = (\n  path: string,\n  data: any = '',\n  {\n    encoding = 'utf-8',\n    overwrite = true,\n    newFile = true\n  }: FileOptions = {}\n) => {\n  path = setPath(path);\n\n  if (newFile && fs.existsSync(path)) {\n    const dir = Path.dirname(path);\n    const ext = Path.extname(path);\n    const baseName = Path.basename(path, ext);\n    let counter = 1;\n\n    while (fs.existsSync(path)) {\n      path = Path.join(dir, `${baseName}(${counter})${ext}`);\n      counter++;\n    }\n  }\n\n  fs.mkdirSync(Path.dirname(path), { recursive: true });\n  overwrite\n    ? fs.writeFileSync(path, data, encoding)\n    : fs.appendFileSync(path, data, encoding);\n};\n\n/**\n * Save object(dict) to file with charset(encoding), create Folder if not exist\n * @remarks\n * # TODO : add `append` func\n */\nconst saveJson = (\n  path: string,\n  data = {},\n  {\n    indent = 2,\n    overwrite = true,\n    newFile = false\n  }: JsonOptions = {}\n) => {\n  saveFile(\n    setPath(path),\n    JSON.stringify(data, null, indent),\n    { overwrite, newFile }\n  );\n};\n\n/**\n * make directory if path not exist\n */\nconst makeDir = (path: string) => {\n  fs.mkdirSync(setPath(path), { recursive: true });\n};\n\n/**\n * copy fies in srcDir to dstDir recursively\n */\nconst copyDir = (srcDir: string, dstDir: string, recursive = true) => {\n  fs.cpSync(setPath(srcDir), setPath(dstDir), { recursive });\n};\n\n\n/**\n * find All Files In Folder(Recursively) By Pattern\n * @param folder\n * @param  arrayOfFiles\n * @param pattern\n */\nconst findFiles = (\n  folder: string,\n  pattern: string | RegExp = '',\n  arrayOfFiles: string[] = []\n) => {\n  if (!fs.existsSync(folder)) return [];\n  const files = fs.readdirSync(folder);\n  arrayOfFiles = arrayOfFiles || [];\n\n  files.forEach(function (file) {\n    if (fs.statSync(folder + '/' + file).isDirectory()) {\n      arrayOfFiles = findFiles(folder + '/' + file, pattern, arrayOfFiles);\n    } else {\n      const regex = pattern instanceof RegExp\n        ? pattern\n        : new RegExp(pattern.replace(/\\*/g, '.*'));\n      if (regex.test(file)) {\n        arrayOfFiles.push(Path.join(folder, '/', file));\n      }\n    }\n  });\n\n  return arrayOfFiles;\n};\n\n// base_path의 하위 폴더 중에 이름에 pattern을 포함하는 폴더\nfunction findFolders(basePath: string, pattern: string | RegExp = ''): string[] {\n  const matchedFolders: string[] = [];\n\n  for (const entry of fs.readdirSync(basePath)) {\n    const fullPath = Path.join(basePath, entry);\n    const regex = pattern instanceof RegExp\n      ? pattern\n      : new RegExp(pattern.replace(/\\*/g, '.*'));\n\n    if (fs.statSync(fullPath).isDirectory() && regex.test(entry)) {\n      matchedFolders.push(slashedFolder(fullPath));\n    }\n  }\n  return matchedFolders;\n}\n\n/**\n * exists Folder(폴더 존재여부)\n */\nconst existsFolder = (folder: string) => fs.existsSync(folder);\n\n\n/**\n * exists Folder(폴더 존재여부)\n */\nconst existsFile = (file: string) => fs.existsSync(file);\n\n/**\n * exists Folder(폴더 존재여부)\n */\nconst exists = (path: string) => fs.existsSync(path);\n\n/**\n * moveFile\n */\nconst moveFile = (\n  srcFolderName: string,\n  dstFolderName: string,\n  srcFileName: string,\n  dstFileName: string\n) => {\n  srcFolderName = slashedFolder(srcFolderName);\n  dstFolderName = slashedFolder(dstFolderName);\n\n  fs.rename(\n    `${srcFolderName}/${srcFileName}`,\n    `${dstFolderName}/${dstFileName}`,\n    (err) => console.log(err)\n  );\n};\n\n/**\n * moveFiles\n */\nconst moveFiles = (\n  srcFolderName: string,\n  dstFolderName: string,\n  srcFileNames: string[],\n  dstFileNames: string[]\n) => {\n  srcFolderName = slashedFolder(srcFolderName);\n  dstFolderName = slashedFolder(dstFolderName);\n\n  !fs.existsSync(dstFolderName) &&\n    fs.mkdirSync(dstFolderName, { recursive: true });\n  for (let i = 0; i < srcFileNames.length; i++) {\n    const srcFileName = srcFileNames[i];\n    const dstFileName = dstFileNames[i];\n    fs.rename(\n      `${srcFolderName}/${srcFileName}`,\n      `${dstFolderName}/${dstFileName}`,\n      (err) => console.log(err)\n    );\n  }\n};\n\n/**\n * rename Files In Folder\n * @param folder\n * @param  filterCb\n * @param  mapCb\n */\nconst renameFilesInFolder = (\n  folder: string,\n  filterCb: Function,\n  mapCb: Function\n) => {\n  folder = `${process.env.DIR_ROOT}/${folder}`;\n  filterCb = (name: string) => name.endsWith('.ts');\n  mapCb = (name: string) => `${folder}/${name}`;\n  return fs\n    .readdirSync(folder)\n    .filter((name) => filterCb(name))\n    .map((name) => mapCb(name));\n};\n\n/*\n * 해당 폴더의 하위 디렉토리(recursive)에 있는 폴더, 파일 삭제\n */\nconst deleteFilesInFolder = (folderPath: string, pattern: string = 'node_modules/,.git/.DS_Store', recursive = true) => {\n  try {\n    // 폴더가 존재하지 않으면 종료\n    if (!fs.existsSync(folderPath)) {\n      return;\n    }\n\n    // 패턴을 배열로 변환하고 정규식으로 변환\n    const patterns = pattern.split(',').map((p) => {\n      // 디렉토리는 그대로 문자열 비교\n      if (p.endsWith('/')) return p;\n      // 와일드카드가 있는 경우 정규식으로 변환\n      if (p.includes('*')) {\n        return new RegExp('^' + p.replace(/\\*/g, '.*') + '$');\n      }\n      // 일반 파일은 그대로 문자열 비교\n      return p;\n    });\n\n    const files = fs.readdirSync(folderPath);\n    for (const file of files) {\n      try {\n        const filePath = Path.join(folderPath, file);\n        const stat = fs.statSync(filePath);\n\n        if (stat.isDirectory() && recursive) {\n          // 디렉토리인 경우\n          const isMatchDir = patterns.some((p) => typeof p === 'string' && p.endsWith('/') && file + '/' === p);\n          if (isMatchDir) {\n            fs.rmSync(filePath, { recursive: true, force: true });\n          } else {\n            deleteFilesInFolder(filePath, pattern, recursive);\n          }\n        } else if (stat.isFile()) {\n          // 파일인 경우\n          const isMatchFile = patterns.some((p) => {\n            if (p instanceof RegExp) {\n              return p.test(file);\n            }\n            return file === p;\n          });\n          if (isMatchFile) {\n            fs.unlinkSync(filePath);\n          }\n        }\n      } catch (err: any) {\n        console.error(`Error processing ${file}: ${err.message}`);\n        continue;\n      }\n    }\n    return pattern\n  } catch (err: any) {\n    console.error(`Error processing folder ${folderPath}: ${err.message}`);\n    return \"\";\n  }\n};\n\n/**\n * substitute in file\n * @param filePath\n * @param replacements {k1: v1, k2: v2, ...} (\"search\" -> \"replace\")\n */\nconst substituteInFile = (filePath: string, replacements: Record<string, string>) => {\n  let content = loadFile(filePath);\n  for (const [key, value] of Object.entries(replacements)) {\n    content = content.replace(new RegExp(key, 'g'), value);\n  }\n  saveFile(filePath, content, { overwrite: true, newFile: false });\n}\n\n\n// & Export AREA\n// &---------------------------------------------------------------------------\nexport {\n  slashedFolder, //\n  composeHangul,\n  setPath, // 상대경로->절대경로(실행 폴더 기준) './dir1/dir2' =>\n  sanitizeName, // 파일명으로 사용가능하도록 문자열 변경\n  loadFile, //\n  loadJson, //\n  saveFile, //\n  saveJson, //\n  makeDir, //\n  copyDir, // 폴더 복사(recursive)\n  findFiles, // 파일 목록\n  findFolders, // 하위 folder 목록\n  existsFolder, // 폴더 존재여부\n  existsFile, // 파일 존재여부\n  exists, // 존재여부\n  moveFile,\n  moveFiles,\n  renameFilesInFolder,\n  deleteFilesInFolder,\n  substituteInFile\n};\n"],"names":["fs","Path","removeBOM","str","replace","slashedFolder","folderName","endsWith","slice","setPath","path","startsWith","join","process","cwd","composeHangul","toString","normalize","sanitizePath","invalidChars","invalidDots","multipleSpaces","trim","sanitizeName","name","loadFile","encoding","readFileSync","loadJson","JSON","parse","saveFile","data","overwrite","newFile","existsSync","dir","dirname","ext","extname","baseName","basename","counter","mkdirSync","recursive","writeFileSync","appendFileSync","saveJson","indent","stringify","makeDir","copyDir","srcDir","dstDir","cpSync","findFiles","folder","pattern","arrayOfFiles","files","readdirSync","forEach","file","statSync","isDirectory","regex","RegExp","test","push","findFolders","basePath","matchedFolders","entry","fullPath","existsFolder","existsFile","exists","moveFile","srcFolderName","dstFolderName","srcFileName","dstFileName","rename","err","console","log","moveFiles","srcFileNames","dstFileNames","i","length","renameFilesInFolder","filterCb","mapCb","env","DIR_ROOT","filter","map","deleteFilesInFolder","folderPath","patterns","split","p","includes","filePath","stat","isMatchDir","some","rmSync","force","isFile","isMatchFile","unlinkSync","error","message","substituteInFile","replacements","content","key","value","Object","entries"],"mappings":"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"}